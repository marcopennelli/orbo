// Code generated by goa v3.14.1, DO NOT EDIT.
//
// system HTTP client types
//
// Command:
// $ goa gen orbo/design

package client

import (
	system "orbo/gen/system"

	goa "goa.design/goa/v3/pkg"
)

// StatusResponseBody is the type of the "system" service "status" endpoint
// HTTP response body.
type StatusResponseBody struct {
	// Camera status list
	Cameras []*CameraInfoResponseBody `form:"cameras,omitempty" json:"cameras,omitempty" xml:"cameras,omitempty"`
	// Motion detection status
	MotionDetectionActive *bool `form:"motion_detection_active,omitempty" json:"motion_detection_active,omitempty" xml:"motion_detection_active,omitempty"`
	// Notification status
	NotificationsActive *bool `form:"notifications_active,omitempty" json:"notifications_active,omitempty" xml:"notifications_active,omitempty"`
	// System uptime in seconds
	UptimeSeconds *int `form:"uptime_seconds,omitempty" json:"uptime_seconds,omitempty" xml:"uptime_seconds,omitempty"`
	// Current pipeline detection mode (disabled, continuous, motion_triggered,
	// scheduled, hybrid)
	PipelineMode *string `form:"pipeline_mode,omitempty" json:"pipeline_mode,omitempty" xml:"pipeline_mode,omitempty"`
	// Pipeline execution mode (always sequential)
	PipelineExecutionMode *string `form:"pipeline_execution_mode,omitempty" json:"pipeline_execution_mode,omitempty" xml:"pipeline_execution_mode,omitempty"`
	// Enabled detectors in the pipeline
	PipelineDetectors []string `form:"pipeline_detectors,omitempty" json:"pipeline_detectors,omitempty" xml:"pipeline_detectors,omitempty"`
	// Whether AI detection is enabled (false when mode=disabled)
	PipelineDetectionEnabled *bool `form:"pipeline_detection_enabled,omitempty" json:"pipeline_detection_enabled,omitempty" xml:"pipeline_detection_enabled,omitempty"`
	// Number of cameras currently running detection
	DetectingCameras *int `form:"detecting_cameras,omitempty" json:"detecting_cameras,omitempty" xml:"detecting_cameras,omitempty"`
}

// StartDetectionResponseBody is the type of the "system" service
// "start_detection" endpoint HTTP response body.
type StartDetectionResponseBody struct {
	// Camera status list
	Cameras []*CameraInfoResponseBody `form:"cameras,omitempty" json:"cameras,omitempty" xml:"cameras,omitempty"`
	// Motion detection status
	MotionDetectionActive *bool `form:"motion_detection_active,omitempty" json:"motion_detection_active,omitempty" xml:"motion_detection_active,omitempty"`
	// Notification status
	NotificationsActive *bool `form:"notifications_active,omitempty" json:"notifications_active,omitempty" xml:"notifications_active,omitempty"`
	// System uptime in seconds
	UptimeSeconds *int `form:"uptime_seconds,omitempty" json:"uptime_seconds,omitempty" xml:"uptime_seconds,omitempty"`
	// Current pipeline detection mode (disabled, continuous, motion_triggered,
	// scheduled, hybrid)
	PipelineMode *string `form:"pipeline_mode,omitempty" json:"pipeline_mode,omitempty" xml:"pipeline_mode,omitempty"`
	// Pipeline execution mode (always sequential)
	PipelineExecutionMode *string `form:"pipeline_execution_mode,omitempty" json:"pipeline_execution_mode,omitempty" xml:"pipeline_execution_mode,omitempty"`
	// Enabled detectors in the pipeline
	PipelineDetectors []string `form:"pipeline_detectors,omitempty" json:"pipeline_detectors,omitempty" xml:"pipeline_detectors,omitempty"`
	// Whether AI detection is enabled (false when mode=disabled)
	PipelineDetectionEnabled *bool `form:"pipeline_detection_enabled,omitempty" json:"pipeline_detection_enabled,omitempty" xml:"pipeline_detection_enabled,omitempty"`
	// Number of cameras currently running detection
	DetectingCameras *int `form:"detecting_cameras,omitempty" json:"detecting_cameras,omitempty" xml:"detecting_cameras,omitempty"`
}

// StopDetectionResponseBody is the type of the "system" service
// "stop_detection" endpoint HTTP response body.
type StopDetectionResponseBody struct {
	// Camera status list
	Cameras []*CameraInfoResponseBody `form:"cameras,omitempty" json:"cameras,omitempty" xml:"cameras,omitempty"`
	// Motion detection status
	MotionDetectionActive *bool `form:"motion_detection_active,omitempty" json:"motion_detection_active,omitempty" xml:"motion_detection_active,omitempty"`
	// Notification status
	NotificationsActive *bool `form:"notifications_active,omitempty" json:"notifications_active,omitempty" xml:"notifications_active,omitempty"`
	// System uptime in seconds
	UptimeSeconds *int `form:"uptime_seconds,omitempty" json:"uptime_seconds,omitempty" xml:"uptime_seconds,omitempty"`
	// Current pipeline detection mode (disabled, continuous, motion_triggered,
	// scheduled, hybrid)
	PipelineMode *string `form:"pipeline_mode,omitempty" json:"pipeline_mode,omitempty" xml:"pipeline_mode,omitempty"`
	// Pipeline execution mode (always sequential)
	PipelineExecutionMode *string `form:"pipeline_execution_mode,omitempty" json:"pipeline_execution_mode,omitempty" xml:"pipeline_execution_mode,omitempty"`
	// Enabled detectors in the pipeline
	PipelineDetectors []string `form:"pipeline_detectors,omitempty" json:"pipeline_detectors,omitempty" xml:"pipeline_detectors,omitempty"`
	// Whether AI detection is enabled (false when mode=disabled)
	PipelineDetectionEnabled *bool `form:"pipeline_detection_enabled,omitempty" json:"pipeline_detection_enabled,omitempty" xml:"pipeline_detection_enabled,omitempty"`
	// Number of cameras currently running detection
	DetectingCameras *int `form:"detecting_cameras,omitempty" json:"detecting_cameras,omitempty" xml:"detecting_cameras,omitempty"`
}

// StartDetectionInternalResponseBody is the type of the "system" service
// "start_detection" endpoint HTTP response body for the "internal" error.
type StartDetectionInternalResponseBody struct {
	// Error message
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// CameraInfoResponseBody is used to define fields on response body types.
type CameraInfoResponseBody struct {
	// Camera unique identifier
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Camera name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Camera device path (e.g., /dev/video0)
	Device *string `form:"device,omitempty" json:"device,omitempty" xml:"device,omitempty"`
	// Camera status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Camera resolution
	Resolution *string `form:"resolution,omitempty" json:"resolution,omitempty" xml:"resolution,omitempty"`
	// Frames per second
	Fps *int `form:"fps,omitempty" json:"fps,omitempty" xml:"fps,omitempty"`
	// Creation timestamp
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// When false, detection pipeline still runs for bounding boxes but no events
	// are created or alerts sent.
	AlertsEnabled *bool `form:"alerts_enabled,omitempty" json:"alerts_enabled,omitempty" xml:"alerts_enabled,omitempty"`
}

// NewStatusSystemStatusOK builds a "system" service "status" endpoint result
// from a HTTP "OK" response.
func NewStatusSystemStatusOK(body *StatusResponseBody) *system.SystemStatus {
	v := &system.SystemStatus{
		MotionDetectionActive:    *body.MotionDetectionActive,
		NotificationsActive:      *body.NotificationsActive,
		UptimeSeconds:            *body.UptimeSeconds,
		PipelineMode:             body.PipelineMode,
		PipelineExecutionMode:    body.PipelineExecutionMode,
		PipelineDetectionEnabled: body.PipelineDetectionEnabled,
		DetectingCameras:         body.DetectingCameras,
	}
	v.Cameras = make([]*system.CameraInfo, len(body.Cameras))
	for i, val := range body.Cameras {
		v.Cameras[i] = unmarshalCameraInfoResponseBodyToSystemCameraInfo(val)
	}
	if body.PipelineDetectors != nil {
		v.PipelineDetectors = make([]string, len(body.PipelineDetectors))
		for i, val := range body.PipelineDetectors {
			v.PipelineDetectors[i] = val
		}
	}

	return v
}

// NewStartDetectionSystemStatusOK builds a "system" service "start_detection"
// endpoint result from a HTTP "OK" response.
func NewStartDetectionSystemStatusOK(body *StartDetectionResponseBody) *system.SystemStatus {
	v := &system.SystemStatus{
		MotionDetectionActive:    *body.MotionDetectionActive,
		NotificationsActive:      *body.NotificationsActive,
		UptimeSeconds:            *body.UptimeSeconds,
		PipelineMode:             body.PipelineMode,
		PipelineExecutionMode:    body.PipelineExecutionMode,
		PipelineDetectionEnabled: body.PipelineDetectionEnabled,
		DetectingCameras:         body.DetectingCameras,
	}
	v.Cameras = make([]*system.CameraInfo, len(body.Cameras))
	for i, val := range body.Cameras {
		v.Cameras[i] = unmarshalCameraInfoResponseBodyToSystemCameraInfo(val)
	}
	if body.PipelineDetectors != nil {
		v.PipelineDetectors = make([]string, len(body.PipelineDetectors))
		for i, val := range body.PipelineDetectors {
			v.PipelineDetectors[i] = val
		}
	}

	return v
}

// NewStartDetectionInternal builds a system service start_detection endpoint
// internal error.
func NewStartDetectionInternal(body *StartDetectionInternalResponseBody) *system.InternalError {
	v := &system.InternalError{
		Message: *body.Message,
	}

	return v
}

// NewStopDetectionSystemStatusOK builds a "system" service "stop_detection"
// endpoint result from a HTTP "OK" response.
func NewStopDetectionSystemStatusOK(body *StopDetectionResponseBody) *system.SystemStatus {
	v := &system.SystemStatus{
		MotionDetectionActive:    *body.MotionDetectionActive,
		NotificationsActive:      *body.NotificationsActive,
		UptimeSeconds:            *body.UptimeSeconds,
		PipelineMode:             body.PipelineMode,
		PipelineExecutionMode:    body.PipelineExecutionMode,
		PipelineDetectionEnabled: body.PipelineDetectionEnabled,
		DetectingCameras:         body.DetectingCameras,
	}
	v.Cameras = make([]*system.CameraInfo, len(body.Cameras))
	for i, val := range body.Cameras {
		v.Cameras[i] = unmarshalCameraInfoResponseBodyToSystemCameraInfo(val)
	}
	if body.PipelineDetectors != nil {
		v.PipelineDetectors = make([]string, len(body.PipelineDetectors))
		for i, val := range body.PipelineDetectors {
			v.PipelineDetectors[i] = val
		}
	}

	return v
}

// ValidateStatusResponseBody runs the validations defined on StatusResponseBody
func ValidateStatusResponseBody(body *StatusResponseBody) (err error) {
	if body.Cameras == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cameras", "body"))
	}
	if body.MotionDetectionActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("motion_detection_active", "body"))
	}
	if body.NotificationsActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("notifications_active", "body"))
	}
	if body.UptimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uptime_seconds", "body"))
	}
	for _, e := range body.Cameras {
		if e != nil {
			if err2 := ValidateCameraInfoResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateStartDetectionResponseBody runs the validations defined on
// start_detection_response_body
func ValidateStartDetectionResponseBody(body *StartDetectionResponseBody) (err error) {
	if body.Cameras == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cameras", "body"))
	}
	if body.MotionDetectionActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("motion_detection_active", "body"))
	}
	if body.NotificationsActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("notifications_active", "body"))
	}
	if body.UptimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uptime_seconds", "body"))
	}
	for _, e := range body.Cameras {
		if e != nil {
			if err2 := ValidateCameraInfoResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateStopDetectionResponseBody runs the validations defined on
// stop_detection_response_body
func ValidateStopDetectionResponseBody(body *StopDetectionResponseBody) (err error) {
	if body.Cameras == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("cameras", "body"))
	}
	if body.MotionDetectionActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("motion_detection_active", "body"))
	}
	if body.NotificationsActive == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("notifications_active", "body"))
	}
	if body.UptimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uptime_seconds", "body"))
	}
	for _, e := range body.Cameras {
		if e != nil {
			if err2 := ValidateCameraInfoResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateStartDetectionInternalResponseBody runs the validations defined on
// start_detection_internal_response_body
func ValidateStartDetectionInternalResponseBody(body *StartDetectionInternalResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	return
}

// ValidateCameraInfoResponseBody runs the validations defined on
// CameraInfoResponseBody
func ValidateCameraInfoResponseBody(body *CameraInfoResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Device == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("device", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.ID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.id", *body.ID, goa.FormatUUID))
	}
	if body.Status != nil {
		if !(*body.Status == "active" || *body.Status == "inactive" || *body.Status == "error") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"active", "inactive", "error"}))
		}
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	return
}
